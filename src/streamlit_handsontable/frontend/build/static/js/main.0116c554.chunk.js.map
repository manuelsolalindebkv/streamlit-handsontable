{"version":3,"sources":["HandOnTableComponent.tsx","StreamlitEventsComponent.tsx","index.tsx"],"names":["registerAllModules","HandsontableComponent","_ref","data","initial_data","df_key","table_version","columns_config","reaction","height","afterChange","onAfterChange","afterRowAdd","onAfterRowAdd","afterRowDelete","onAfterRowDelete","afterReaction","onAfterReaction","onReload","hide_columns","columns","initial_tabledata","reaction_id","hotcolumn_settings","forEach","col","index","column_dict","hasOwnProperty","push","console","log","tabledata","setTableData","React","useState","metadata_columns","filter","startsWith","id_column","indexOf","version_column","hotTableComponent","useRef","useEffect","hot","current","hotInstance","reaction_type","alert_message","alert","rows","row","row_index","updated_row","map","value","col_index","setSourceDataAtCell","undo","error","hidden_columns_ids","x","createElement","HotTable","dropdownMenu","hiddenColumns","indicators","columnSorting","filters","contextMenu","colHeaders","rowHeaders","sortByRelevance","autoWrapCol","autoWrapRow","licenseKey","changes","source","hotTableClass","length","change","rowIndex","columnIndex","oldValue","newValue","column","includes","empty_cells","undefined","physical_changes","toPhysicalRow","toPhysicalColumn","list_of_changes","physical_change","column_name","column_config","column_type","parseFloat","metadata_dict","reduce","acc","getSourceDataAtCell","old_value","new_value","version","suspendRender","suspendExecution","resumeRender","resumeExecution","afterCreateRow","amount","physicalRowIndex","beforeCreateRow","filtersPlugin","getPlugin","beforeRemoveRow","beforeRowDelete","physicalRows","row_ids","colWidths","Math","min","stretchH","ref","dateFormat","readOnly","manualColumnResize","col_settings","HotColumn","Object","assign","key","version_count","withStreamlitConnection","args","override_height","df_json","df_data","JSON","parse","local_reaction","setLocalReaction","columns_with_dates","Streamlit","setFrameHeight","plotlyEventHandler","event","response","response_str","stringify","setComponentValue","ReactDOM","render","StrictMode","StreamlitEventsComponent","document","getElementById"],"mappings":"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","file":"static/js/main.0116c554.chunk.js","sourcesContent":["import React, { useCallback } from \"react\"\nimport { HotColumn, HotTable } from \"@handsontable/react\"\nimport \"handsontable/dist/handsontable.full.css\"\nimport { useEffect } from \"react\"\nimport { useRef } from \"react\"\n// import Handsontable from 'handsontable';\nimport { registerAllModules } from 'handsontable/registry';\n\n\n\ninterface TableProps {\n  data: {\n    columns: string[]\n    index: number[]\n    data: any[][]\n  }\n  df_key: string\n  table_version: number\n  // Dict[str, dict]\n  columns_config: { [key: string]: { [key: string]: any } }\n  reaction: any\n  height: number\n  afterChange: (data: any) => void\n  afterRowAdd: (data: any) => void\n  afterRowDelete: (data: any) => void\n  afterReaction: () => void\n  onReload: () => void\n  hide_columns: string[]\n}\n\n// register Handsontable's modules\nregisterAllModules();\n\nconst HandsontableComponent: React.FC<TableProps> = ({\n  data: initial_data,\n  df_key,\n  table_version,\n  columns_config,\n  reaction,\n  height,\n  afterChange: onAfterChange,\n  afterRowAdd: onAfterRowAdd,\n  afterRowDelete: onAfterRowDelete,\n  afterReaction: onAfterReaction,\n  onReload,\n  hide_columns,\n}) => {\n  const { columns, data: initial_tabledata } = initial_data\n  const { reaction_id } = reaction\n\n  //updata columns config for all columns\n  let hotcolumn_settings: { [key: string]: any }[] = []\n  columns.forEach((col,index) => {\n    let column_dict: { [key: string]: any } = {}\n    if (columns_config.hasOwnProperty(col)) {\n      column_dict = columns_config[col]\n    } \n    column_dict['data'] = index\n    hotcolumn_settings.push(column_dict)\n  })\n\n  console.log('hotcolumn_settings', hotcolumn_settings)\n\n  \n\n\n  const [tabledata, setTableData] = React.useState(initial_tabledata)\n  \n  // columns that start with _ are metadata columns\n  const metadata_columns = columns.filter((col) => col.startsWith('_'))\n  const id_column = columns.indexOf('_id')\n  const version_column = columns.indexOf('_version')\n  \n  \n  \n  const hotTableComponent = useRef<any>(null);\n\n  const afterChange = (changes: any, source: any) => {\n    const hotTableClass = hotTableComponent.current\n\n    if (reaction_id) {\n      console.log('skiping afterchange')\n      return\n    } else {\n      console.log('afterchange triggered','source: ', source)\n    }\n\n    if (hotTableClass) {\n\n      let hotInstance = hotTableClass.hotInstance\n      if (changes && changes.length > 0) {\n\n        // filter out changes in metadata columns\n        changes = changes.filter((change: [number, number, any, any]) => {\n          const [rowIndex, columnIndex, oldValue, newValue] = change\n          const column = columns[columnIndex]\n          return !metadata_columns.includes(column)\n        })\n\n        // filter out changes where null is replace by undefined\n        changes = changes.filter((change: [number, number, any, any]) => {\n          const [rowIndex, columnIndex, oldValue, newValue] = change\n          const empty_cells = [null, undefined, '']\n          return !(empty_cells.includes(oldValue) && empty_cells.includes(newValue))\n        })\n          console.log('changes', changes)\n\n        let physical_changes = changes.map((change: [number, number, any, any]) => {\n          const [rowIndex, columnIndex, oldValue, newValue] = change\n          const physicalRowIndex = hotInstance.toPhysicalRow(rowIndex);\n          const physicalColumnIndex = hotInstance.toPhysicalColumn(columnIndex);\n          return [physicalRowIndex, physicalColumnIndex, oldValue, newValue]\n        })\n\n        console.log('physical_changes', physical_changes)\n\n        let list_of_changes = []\n        for (let physical_change of physical_changes) {\n\n          // check the format of the new value\n          let [rowIndex, columnIndex, oldValue, newValue] = physical_change\n          let column_name = columns[columnIndex]\n          if (columns_config.hasOwnProperty(column_name)) {\n            let column_config = columns_config[column_name]\n            if (column_config.hasOwnProperty('type')) {\n              let column_type = column_config['type']\n              if (column_type === 'numeric') {\n                newValue = parseFloat(newValue)\n              } else if (column_type === 'checkbox') {\n                //make sure newValue is boolean\n                newValue = newValue === true\n              } else if (column_type === 'date') {\n                //use text value for date\n                // pass\n              } else if (column_type === 'text') {\n                //pass\n              }\n            }\n          }\n\n\n\n          //create dictionary with values in metadata columns\n          let metadata_dict = metadata_columns.reduce((acc: { [key: string]: any }, col) => {\n            let col_index = columns.indexOf(col)\n            let value = hotInstance.getSourceDataAtCell(physical_change[0], col_index)\n            acc[col] = value\n            return acc\n          }, {})\n          \n          let column = columns[columnIndex]\n          list_of_changes.push({\n            row_index: rowIndex,\n            column: column,\n            old_value: oldValue,\n            new_value: newValue,\n            ...metadata_dict\n          })\n\n          // increase version count for row\n          let version = hotInstance.getSourceDataAtCell(rowIndex, version_column)\n          hotInstance.suspendRender()\n          hotInstance.suspendExecution()\n          hotInstance.setSourceDataAtCell(rowIndex, version_column, version + 1)\n          hotInstance.resumeRender()\n          hotInstance.resumeExecution()\n        }\n        \n        console.log('list_of_changes', list_of_changes)\n\n        if (list_of_changes.length > 0) {\n          onAfterChange(list_of_changes)\n        }\n        else {\n          console.log('no changes')\n        }\n\n      }\n\n    } else {\n      console.error('hotTableClass is null')\n      onAfterChange([])\n    }\n\n  }\n\n  const beforeCreateRow = (index: any, amount: any, source: any) => {\n    console.log('beforeCreateRow', index, amount, source)\n    const hotTableClass = hotTableComponent.current\n    if (!hotTableClass) {\n      console.error('hotTableClass is null')\n      return false\n    } else {\n      let hotInstance = hotTableClass.hotInstance\n      // check if filters are applied\n\n      // Get the Filters plugin\n      const filtersPlugin = hotInstance.getPlugin('Filters');\n\n      console.log('filtersPlugin', filtersPlugin)\n      console.log('hotTableClass', hotTableClass)\n      console.log('hotInstance', hotInstance)\n      // TODO: disable adding row if filters are applied\n\n    }\n\n\n    // if (index === 0) {\n    //   console.log('beforeCreateRow', index, amount, source)\n    //   return false\n    // }\n  }\n\n  const afterRowAdd = (row_index: any, amount: any) => {\n    console.log('row added ', row_index)\n\n    const hotTableClass = hotTableComponent.current\n\n    if (reaction_id) {\n      console.log('skiping afterRowAdd')\n      return\n    }\n\n    if (row_index && hotTableClass) {\n      let hotInstance = hotTableClass.hotInstance\n      let physicalRowIndex = hotInstance.toPhysicalRow(row_index);\n      console.log('physicalRowIndex', physicalRowIndex)\n      onAfterRowAdd(physicalRowIndex)\n    } else {\n      // TODO: error adding row before first row\n      if (row_index === 0) {\n        onAfterRowAdd(row_index)\n      } else {\n        console.error('hotTableClass is null')\n      }\n    }\n  }\n\n\n  const beforeRowDelete = (index: any, amount: any, physicalRows: any, source: any) => {\n    console.log(index, amount, physicalRows, source)\n\n    const hot = hotTableComponent.current.hotInstance\n    let row_ids = physicalRows.map((index: number) => hot.getSourceDataAtCell(index, id_column))\n    console.log('row_ids', row_ids)\n    onAfterRowDelete(row_ids)\n  }\n\n\n  // on component mount with hooks\n  useEffect(() => {\n    console.log('reaction triggered')\n    const hotTableClass = hotTableComponent.current\n    // setTableData(initial_tabledata)\n    // onReload()\n\n    const hot = hotTableClass.hotInstance\n\n    const { reaction_type } = reaction\n\n    \n\n    if (reaction_type === 'update_rows') {\n        if (reaction.hasOwnProperty('alert_message')) {\n          const alert_message = reaction['alert_message']\n          alert(alert_message)\n        }\n        const rows = reaction['rows']\n        for (let row of rows) {\n          let row_index = row['_row_index']\n\n          // use columns to create the updated row\n          let updated_row = columns.map((col) => row[col])\n\n          // update row with updated_row data\n          // hot.populateFromArray(row_index, 0, [updated_row]);\n\n          // update row with updated_row data\n          // hot.suspendRender()\n          console.log('updating row', row_index, updated_row)\n\n          updated_row.map((value, col_index) => {\n            // if (value !== null){\n              hot.setSourceDataAtCell(row_index, col_index, value)\n            // }\n          })\n          // hot.resumeRender()\n        }\n\n    } else if (reaction_type === 'undo') {\n      // trigger an alert\n      alert('Error: undoing')\n\n      hot.undo()\n      \n    } else if (reaction_type === 'error') {\n      // trigger an alert\n      const error = reaction['error_message']\n      alert('Error: ' + error)\n    }\n\n    onAfterReaction()\n    \n    // onAfterReaction()\n    // hot.resumeExecution()\n    // hot.resumeRender()\n    \n  }, [reaction_id])\n\n  useEffect(() => {\n    const hotTableClass = hotTableComponent.current\n    console.log('initial_tabledata changed')\n    \n  }, [initial_tabledata])\n\n  useEffect(() => {\n    \n    setTableData(initial_tabledata)\n    \n  }, [table_version])\n\n\n\n\n\n\n  let hidden_columns_ids = hide_columns.map((col) => columns.indexOf(col)).filter((x) => x !== -1)\n\n  console.log(reaction)\n  // console.log(hidden_columns_ids)\n\n  return (\n    <HotTable\n      data={tabledata}\n      height={height}\n      dropdownMenu={['filter_by_condition', 'filter_action_bar', 'filter_by_value']}\n      hiddenColumns={{\n        columns: hidden_columns_ids,\n        indicators: false,\n      }}\n      columnSorting={true}\n      filters={true}\n      contextMenu={true} //add and remove rows\n      // contextMenu={['row_above', 'row_below', '---------', 'undo', 'redo']}\n      colHeaders={columns}\n      rowHeaders={true}\n      sortByRelevance={true}\n      autoWrapCol={true}\n      autoWrapRow={true}\n      licenseKey=\"non-commercial-and-evaluation\"\n      afterChange={afterChange}\n      afterCreateRow={afterRowAdd}\n      beforeCreateRow={beforeCreateRow}\n      beforeRemoveRow={beforeRowDelete}\n      // afterRemoveRow={afterRowDelete}\n      colWidths={columns.map((col) => Math.min(999, 100))} // FIXME\n      stretchH=\"all\"\n      ref={hotTableComponent}\n      undo={true}\n      dateFormat=\"YYYY-MM-DD\"\n      columns={columns.map((col) => {\n        return {\n          readOnly: metadata_columns.includes(col),\n        }\n      })}\n      manualColumnResize={true} // Allow column width to be changed\n    >\n      \n      {hotcolumn_settings.map((col_settings, index) => {\n        return <HotColumn \n              key={index} \n              {...col_settings} \n              readOnly={metadata_columns.includes(columns[index])}\n        />\n      })}\n\n    </HotTable>\n  )\n}\n\nexport default HandsontableComponent\n","import { Streamlit, withStreamlitConnection } from \"streamlit-component-lib\";\nimport React, { useEffect } from \"react\";\n// import HandsOnTable from \"./HandsOnTableExample\";\nimport HandsontableComponent from \"./HandOnTableComponent\";\n\n\n\n\n// const jsonData = {\n//   columns: [\"a\", \"b\", \"c\"],\n//   index: [0, 1, 2, 3, 4],\n//   data: [\n//     [-0.2203645667, -0.1364460677, 0.7803492434],\n//     [-1.1966197248, 1.1900065576, 0.3441884038],\n//     [0.6643105109, -0.4865369531, 0.9699144943],\n//     [1.4745054581, -0.2389977022, 1.2352231319],\n//     [0.3313587927, 0.146335964, 0.0602939244]\n//   ]\n// };\n\nvar version_count = 1;\n\nconst StreamlitEventsComponent = ({ args }: { args: any }) => {\n  const override_height = args[\"override_height\"];\n  const df_json = args[\"df_json\"];\n  const df_data = JSON.parse(df_json)\n  const table_version = args[\"table_version\"];\n  const hide_columns = args[\"hide_columns\"];\n  const reaction = JSON.parse(args[\"reaction\"]);\n  const df_key = args[\"df_key\"];\n  const columns_config = JSON.parse(args[\"columns_config\"]);\n\n  const { reaction_id } = reaction;\n\n  const [local_reaction, setLocalReaction] = React.useState(reaction);\n\n  console.log(df_data);\n  console.log(columns_config);\n\n  const { columns } = df_data;\n  const columns_with_dates: string[] = columns.filter((col: string, index: number) => {\n    if (columns_config.hasOwnProperty(col)) {\n      if (columns_config[col].hasOwnProperty('type')) {\n        if (columns_config[col]['type'] === 'date') {\n          return true;\n        }\n      }\n    }\n  });\n  const columns_with_dates_index: number[] = columns_with_dates.map((col: string) => columns.indexOf(col));\n  console.log('columns_with_dates', columns_with_dates)\n  // // df_data.data is an array of arrays that has numeric objects that are time in milliseconds\n  // // We need to convert them to date strings of format 'YYYY-MM-DD'\n  // df_data.data.forEach((row: any[]) => {\n  //   columns_with_dates_index.forEach((col_index: number) => {\n  //     row[col_index] = new Date(row[col_index]).toISOString();\n  //   });\n  // });\n\n\n  useEffect(() => {\n    Streamlit.setFrameHeight(override_height);\n  }, [override_height]);\n\n\n  /** Click handler for plot. */\n  const plotlyEventHandler = (data: any, event: string) => {\n\n    var response: { [key: string]: any } = {};\n    if (event === 'afterChange') {\n      response[event] = data;\n    }\n\n    if (event === 'afterRowAdd') {\n      response[event] = data;\n    }\n    \n    if (event === 'afterRowDelete') {\n      response[event] = data;\n    }\n\n    if (event === 'afterUndo') {\n      response[event] = true;\n    }\n\n    version_count += 1;\n    response['version'] = version_count;\n\n    console.log('version_count', version_count);\n    \n    console.log('response', response);\n    let response_str: string;\n    response_str = JSON.stringify(response);\n    // setLocalReaction({reaction_id:undefined});\n    let returned_value = Streamlit.setComponentValue(response_str);\n    \n\n  };\n\n  useEffect(() => {\n    setLocalReaction(reaction);\n  },[reaction_id]) \n\n  const afterReaction = () => {\n    console.log('afterReaction');\n    setLocalReaction({reaction_id:undefined});\n  }\n\n  // console.log('local_reaction', local_reaction);\n\n  return(\n    <div>\n      <HandsontableComponent\n          data={df_data} \n          df_key={df_key}\n          columns_config={columns_config} \n          table_version={table_version}\n          reaction={local_reaction}\n          height={override_height}\n          afterChange={(data) => plotlyEventHandler(data,'afterChange')}\n          afterRowAdd={(data) => plotlyEventHandler(data,'afterRowAdd')}\n          afterRowDelete={(data) => plotlyEventHandler(data,'afterRowDelete')}\n          afterReaction={afterReaction}\n          onReload={() => console.log('reloaded')}\n          hide_columns={hide_columns}\n          />\n    </div>\n  )\n\n  \n  \n};\n\nexport default withStreamlitConnection(StreamlitEventsComponent);\n\n","import React from \"react\"\nimport ReactDOM from \"react-dom\"\nimport StreamlitEventsComponent from \"./StreamlitEventsComponent\"\n\nReactDOM.render(\n  <React.StrictMode>\n    <StreamlitEventsComponent />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n)\n"],"sourceRoot":""}